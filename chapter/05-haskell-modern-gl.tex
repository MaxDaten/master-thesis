\chapter{Funktionale Programmierung \& Modern OpenGL}
\label{chap:haskell-modern-gl}

\begingroup
\setlength\intextsep{0pt}
\section{Anwendung von Haskell mit Modern OpenGL Konzepten}\label{sec:haskell-gl-anwendung}

Viele der in \fref{sec:overhead-und-flexibilitaet} genannten Erweiterungen wurden mit dem Ziel entwickelt die OpenGL API zu vereinfachen. Die neuen Konzepte harmonieren dabei sehr gut mit OpenGL.

\paragraph{\acl{DSA} \& Separate Program Objects} und die verstärkte Verwendung von Buffern für Daten und Kommandos (\ac{MDI}) und der dadurch reduzierte API Overhead soll neue Spielräume eröffnen. Während dies oft damit beworben wird, dass die CPU wieder interessantere Dinge tun kann, lässt sich auch argumentieren, dass sich die neuen Spielräume für gänzlich neue Ansätze in der Projektstruktur und Wahl der Mittel nutzen lassen. Die generelle Reduzierung des Overheads kommt dabei auch Haskell zugute. Zusätzlich lässt sich aber auch Haskell dazu als Hebel nutzen, um die bessere Modularität von \ac{DSA} voll auszuschöpfen.

\begin{wrapfigure}{r}{0.5\linewidth}
\centering
\fbox{
\begin{minipage}[t]{0.9\linewidth}
\begin{smaller}
\paragraph{Quine}
Quine\footnote{https://github.com/ekmett/quine/} ist ein kleines Hobby Projekt von Edward Kmett. Aktuell basiert das Projekt auf den neuen OpenGL Haskell-Bindings der \texttt{gl} Bibliothek. Die Demo Szenen sind aktuell nur Fragment-Shader Demos von Shadertoy\footnote{https://www.shadertoy.com/}. Langfristiges Ziel von Quine ist laut Edward Kmett eine Bibliothek in Haskell zu erschaffen die eine Sammlung der Best-Practices von Modern OpenGL zugänglich macht. Der Autor dieser Arbeit beteiligt sich an dem Projekt und hat schon kleinere allgemeine Teile aus der hier beschriebenen Engine nach Quine portiert.
\end{smaller}
\end{minipage}
}
\end{wrapfigure}

Die \textit{Separate Program Objects} lassen sich dabei schon in OpenGL 4.1 als Vorboten von \ac{DSA} betrachten. Wie bereits beschrieben lassen sich über diese OpenGL Erweiterung die Uniform Variablen der einzelnen Shader-Stufen direkt über das Program-Objekt setzen. In Verbindung mit einer |StateVar| (siehe Beispielimplementierung \fref{sec:src-statevar}) und wenigen zusätzlichen Definitionen, lassen sich in Haskell elegante Schnittstellendatentypen für Shader definieren, die sich in Zukunft automatisch generieren ließen. \ref{lst:uniform-beispiel} gibt ein Beispiel wie sich eine Shader-Schnittstelle über funktionale Konzepte zusammensetzen lässt.

\endgroup
% Viele Portierungen von Konsole zu PC erwiesen sich oft als zusätzlich aufwändig, da spezielle Optimierungen auf einzelne Anwendungen die Wartung entsprechender Abschnitte deutlich erschwerten (\warn{BELEG}).


\section{Grafik-Engines in Haskell}

C bzw. C++ ist quasi der Industriestandard in der Grafik- und Spieleprogrammierung. Doch gibt es auch einige Open-Source Engines die in anderen Sprachen implementiert wurden. Die folgende Betrachtung beschränkt sich auf Engines die entweder direkt in Haskell umgesetzt wurden oder die auf Bindings zu bestehenden Open-Source Engines basieren.

\subsection{HGamer3D}

\textit{HGamer3D}\footnote{http://www.hgamer3d.org/} basiert auf (nich kompletten) Haskell-Bindings zu \textit{Ogre}\footnote{http://www.ogre3d.org/}. Ogre ist eine objektorientierte Open-Source Grafik-Engine geschrieben in C++. Ohne weiter auf die Fähigkeiten der Ogre Engine einzugehen, stellt sich oft die Adaptierunung von imperativen Bibliotheken auf funktionale Konzepte als aufwändig und nicht immer optimal heraus. Insbesondere dass die Haskell-Bindings zu komplexen C++ \acsp{API} größtenteils von Hand erzeugt werden müssen, setzt immer noch hohe Hürden.

Auch wenn Ogre als Framework viele Strukturen und Lösungsansätze für gängige Probleme in der 3D Computergrafik und Spieleprogrammierung bereitstellt, ließen sich viele Ansätze auch direkt funktional umsetzen, ohne große und schwerfällige \acsp{API} adaptieren zu müssen.

Zum Beispiel verfolgen beide Welten zum Teil gänzlich andere Grundprinzipien. So sind Daten in Haskell prinzipiell unveränderlich während in C++ Daten prinzipiell veränderlich sind. Haskell erlaubt unter anderem deswegen andere Ansätze der Nebenläufigkeit (Concurrency). Speziell Nebenläufigkeiten stellen immer noch in komplexen Softwareprojekten eine große Hürde dar. Die Adaption einer C++-Biblithek kann das Ausnutzen vieler Vorteile von Haskell behindern (weitere Ausführungen in \fref{sec:warum-haskell}).

Zusätzlich entstehen durch Bindings zu externen Bibliotheken neue Abhängigkeiten, die oft eine Anpassung der Tool-Chain erfordern, da sie nicht in das bestehende Ökosystem passen. Dies erhöht die Komplexität des Gesamtsystems. Die Erfahrung des Autors hat gezeigt, dass externe Bindings oft zu Komplikationen führen, spätestens dann, wenn die Anwendung die Entwicklungsumgebung verlässt. In der Praxis lassen sich aber selten Abhhängigkeiten zu anderen Sprachen komplett vermeiden. Insbesondere in der Grafikprogrammierung mit \textit{OpenGL} werden die eigentlichen Bindings zu der \textit{OpenGL}-API benötigt. Zusätzlich muss noch ein plattformabhängiger Render-Kontext erzeugt werden. Dessen Erzeugung ist nicht Teil von \textit{OpenGL} und erfordert eine weitere externe Komponente.

Meinung des Autors: Es sollten möglichst wenige Fremdabhängigkeiten aus anderen Sprachen genutzt werden, leider ist dies nicht immer möglich (Weitere Ausführungen in \fref{sec:probleme-haskell}). Mit den Ogre Bindings wird die eine komplexe schwer funktional bezwingbare \acs{API} (z.B. \textit{OpenGL}) mit einer anderen ersetzt. Vorteil ist unbestritten, dass die Engine ausgereift ist und vieles nicht erst neu implementiert werden muss.

\subsection{LambdaCube 3D}

\textit{LambdaCube 3D}\footnote{https://lambdacube3d.wordpress.com/} ist eine in Haskell definierte und mächtige \ac{DSL}, die es erlaubt Grafikanwendungen bis hin zum Shader komplett in Haskell zu formulieren. Da \textit{OpenGL} eine komplexe und unübersichtliche \acs{API} ist, ist die \ac{DSL} entsprechend komplex und unübersichtlich. Zusätzlich basiert das \textit{OpenGL}-Backend noch auf der Version 3.2, sodass viele neue Shader-Möglichkeiten (z.B. Compute Shader ab 4.3) gar nicht abgedeckt sind. Die Dokumentation beschränkt sich auf den Blog und eine handvoll Beispielen, so dass es schwer ist einen Zugang zu der DSL zu erhalten.


Auch generell stellt sich bei \textit{OpenGL} die Frage, wie sinnvoll es ist die komplexe \acs{API} in einer anderen Sprache komplett abzubilden. \textit{OpenGL} besitzt viele erlaubte und nicht erlaubten Zustände. Die erlaubten und nicht erlaubten Zustände sind zudem mitunter treiberspezifisch. Hinzu kommen diverse Erweiterungen, die die Verhaltensweise der \acs{API} massiv beeinflussen und gültige und ungültige Zustände hinzufügen oder entfernen können.

Die persönliche Einschätzung des Autors ist, dass sich OpenGL nicht in einem vertretbaren Aufwand komplett abbilden lässt. Der Aufwand wäre ungefähr mit dem vergleichbar, den Grafikkartenhersteller bei der Implementierung ihrer Grafikkartentreiber betreiben (weitere Ausführungen in \fref{chap:modern-opengl}). Deswegen sollte eine Auswahl der direkten OpenGL Bindings getroffen werden um sie punktuell in funktionale Konzepte zu gießen.

% \subsection{Elm}

% \subsection{Gloss}
% Gloss (2d) ist ein schönes Beispiel dafür wie sich mit einem OpenGL backend und mit der konzentration auf das wesentliche eine klare funktionale api schaffen lässt die einfach anzuwenden ist.
