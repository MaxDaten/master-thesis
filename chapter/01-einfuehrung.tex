\chapter{Einführung und Wegweiser}

Diese Einführung dient als Wegweiser durch diese Arbeit und soll einen kurzen Überblick über die folgenden Kapitel und deren Inhalt geben.

\section{Motivation}
In \fref{chap:engine-uebersich} starten wir mit einer kleinen Übersicht über die aktuellen Strömungen der Spiele- und Grafikengine-Entwicklung. Spieleengines zählen schon länger mit zu den komplexesten und dynamischsten Softwareprojekten. Aus den Anforderungen an Spiele- und Grafikengines lassen sich Schlüsse und Erfahrungswerte ableiten, die sich generell auf andere komplexe Softwareporjekte übertragen lassen. Es wird fortlaufend nach Mitteln und Wegen geforscht die Komplexität und Dynamik von großen Softwareprojekten beherrschbar zu halten. In den letzten Jahren wurden viele neue Paradigmen und Projektstrukturen entwickelt, damit komplexe Software beherrschbar, wartbar und anpassbar bleibt.

Abseits der Komplexität von Spieleengines gibt es seit wenigen Jahren Bestrebungen die bestehenden Grafikschnittstellen wie DirectX oder OpenGL flexibler zu gestalten aber auch deutlich zu entschlacken. In \fref{chap:modern-opengl} betrachten wir diese Entwicklung exemplarisch an OpenGL, mit dem speziellen Fokus auf \textit{Modern OpenGL}. Viele Neuerungen ermöglichen oder fordern gar neue Denkansätze für die Entwicklung von Grafikanwendungen. In dieser Arbeit werden wir Ansätze entwickeln diese mit Haskell für uns Nutzbar zu machen. Genauer wird in \fref{chap:haskell-modern-gl} analysiert wie sich Haskell und Modern OpenGL zusammen geschickt nutzen lassen und warum dies sinnvoll sein kann.

\section{Ziel}
Von der allgemeinen Analyse und Begründung wie sich Haskell und OpenGL im Tandem nutzen lassen, wird sich der Kern der Arbeit damit befassen, eine flexible Grafikpipeline in Haskell zu entwickeln. Zu den großen Stärken von Haskell zählen zum einen der \textit{mögliche} hohe Grad an Komponierbarkeit von Funktionalitäten und zum anderen die Möglichkeit zur Abstraktion. Wir werden im \fref{chap:ueberblick-pipeline} eine Hand voll abstrakter funktionaler Konzepte verwenden um eine möglichst hohe Komponierbarkeit der Pipeline zu erreichen. Anhand von kleinen Beispielen wird demonstriert, dass sich Bausteine entwickeln lassen, die sich leicht zu größeren Systemen zusammen gesetzt werden können. Dank Arrow-Notation, die kurz in \fref{chap:ueberblick-pipeline} vorgestellt wird, bleiben komplexe Systeme übersichtlich und verständlich.

Neben der theoretischen Konzeption ist ein wesentlicher Teil dieser Arbeit die praktische Umsetzung der Grafikengine auf Basis der konzipierten Grafikpipeline. Als das State of the Art Echtzeit Render-Verfahren gilt aktuell das Konzept des \ac{PBR}. Dieses Verfahren wird in \fref{chap:pbr} kurz vorgestellt, während das Ziel der praktischen Arbeit darin bestand, dieses Verfahren mit der entwickelten Grafikpipline umzusetzen. Entsprechend finden sich in der schriftlichen Ausarbeitung oft Verweise auf die praktischen Implementierungen im Projekt.

\section{Ergebnis}
Das Resultat der praktischen Umsetzung der \ac{PBR} Pipeline wird in \fref{chap:anwendung} umrissen und anschließend in \fref{chap:analyse} kurz sowohl auf ihr Laufzeitverhalten und grafischen Qualität beurteilt als auch unter produktiven Gesichtspunkten, wie zum Beispiel Flexibilität und Wartbarkeit. Probleme und Stolpersteine, die sich während der praktischen Umsetzung möglicherweise aufgetan haben, werden aber ebenso kurz benannt und eingeordnet.

Abgeschlossen wird der schriftliche Teil der Arbeit in \fref{chap:ausblick} mit einem kleinen Ausblick auf mögliche Ansätze Haskell für weitere Bereiche der Engine zu nutzen.
