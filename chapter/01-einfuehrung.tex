\chapter{Einführung und Wegweiser}

Diese Einführung dient als Wegweiser durch diese Arbeit und soll einen kurzen Überblick über die folgenden Kapitel und deren Inhalt geben.

\section{Überblick \& Motivation}
In \fref{chap:engine-uebersicht} wird mit einer einer kleinen Übersicht über die aktuellen Strömungen der Spiele- und Grafik-Engine-Entwicklung begonnen. Spiele-Engines zählen schon länger mit zu den komplexesten und dynamischsten Softwareprojekten. Aus den Anforderungen an Spiele- und Grafik-Engines lassen sich Schlüsse und Erfahrungswerte ableiten, die sich generell auf andere komplexe Softwareporjekte übertragen lassen.

Abseits der Komplexität von Spiele-Engines gibt es seit wenigen Jahren Bestrebungen die bestehenden, über die Jahre gewachsenen, Grafikschnittstellen wie \textit{DirectX} oder \textit{OpenGL} flexibler zu gestalten aber auch in vielen Bereichen deutlich zu \warn{entschlacken}. Das \fref{chap:modern-opengl} betrachtet diese Entwicklung exemplarisch an \textit{OpenGL}, und konkretisiert den Begriff \textit{Modern OpenGL} mit praktischen Bezügen.

Viele Neuerungen ermöglichen oder erzwingen neue Denkansätze für die Entwicklung von Grafikanwendungen. In Kombination mit den Anforderungen und Bedingungen von komplexen Softwareprojekten wird in \fref{chap:haskell-modern-gl} anhand von Haskell analysiert, ob und wie funktionale Programmierung bei der Erfüllung der Anforderungen hilfreich sein kann.

\section{Ziel}
Der Kern der Arbeit wird damit befassen, eine flexible und komponierbare Grafikpipeline in Haskell zu entwickeln. In \fref{chap:ueberblick-pipeline} werden eine Hand voll abstrakter funktionaler Konzepte erläutert und dazu verwendet, eine möglichst hohe Komponierbarkeit der Pipeline-Bausteine zu erreichen. Es wird anhand von kleinen Beispielen demonstriert, wie sich diese Bausteine entwickeln und leicht zu zu größeren Systemen zusammensetzen lassen. Die kurz vorgestellte sogenannte Arrow-Notation soll dabei helfen, komplexe Systeme übersichtlich und verständlich zu halten.

Als aktueller Stand der Technik unter den Echtzeit Rendering-Verfahren gilt das Konzept des \acl{PBR}. Dieses Verfahren wird in theoretischen und praktischen Grundlagen in \fref{chap:pbr} vorgestellt. Praktisches Ziel wird es sein, das \ac{PBR} Konzept mithilfe des zuvor entwickelten Pipeline-Konzepts zur Anwendung zu bringen.

\section{Ergebnis}
In \fref{chap:anwendung} wird exemplarisch ein Renderschritt der Pipeline als Baustein implementiert, und in \fref{lst:src-pipeline} im Appendix das zusammengesetzte Gesamtsystem der Implementierung abgebildet. Darüber hinaus ist das Gesamtprojekt zu dieser Arbeit als DVD im Appendix in \fref{chap:dvd} angefügt.

Die entwicklete \ac{PBR}-Pipeline wird in \fref{chap:analyse} sowohl auf ihr Echtzeitverhalten als auch grafische Qualität beurteilt. Zusätzlich werden die produktiven Gesichtspunkte, wie zum Beispiel Flexibilität und Wartbarkeit, beleuchtet. Probleme und Stolpersteine, die sich während der praktischen Umsetzung möglicherweise aufgetan haben, werden ebenso kurz benannt und eingeordnet.

Abgeschlossen wird der schriftliche Teil der Arbeit in \fref{chap:ausblick} mit einem kleinen Überblick über zukünftige Ansätze und Bereiche, in denen die Grafik-Engine sich sinnvoll erweitern oder anwenden ließe.

\warn{Image}
