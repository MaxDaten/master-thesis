\chapter{Überblick über die Engine}

\section{Das Rendersystem}

\warn{Wir beschreiben den sinn und zweck des Renderystems hier. Das Rendersystem ist der Kern der Renderkomponente der Engine. Die Aufgabe des Rendersystems ist eine Eingabe zu einem Bild darzustellen... Im Konkreten Fall erhält das RenderSystem eine Szenenbeschreibung als Eingabe und führt auf Basis dieser alle definierten Schritte um die Szene in der gewünschten Darstellung als Bild zu synthetisieren.}

\subsection{Mealy als Formale Basis}

Das Rendersystem basiert auf dem Konzept eines Mealy Automatens \parencite{Mealy1955}. Ein Mealy Automat ist \ac{FST}, ein spezieller endlicher Automat, der nicht nur seine Eingabesprache vom Eingabeband akzeptiert sondern auch eine Ausgabe auf einem Ausgabeband erzeugt. Ein Transduktor übersetzt die Eingabesprache in eine Ausgabesprache. Bei dem Mealy Automaten als spezielle Form eines \ac{FST} definiert sich die Ausgabe über den momentanen Zustand und die Eingabe auf diesem Zustand. Formal lässt sich ein Mealy Automat $\mathbfcal{M}$ als 6-Tupel wie folgt definieren:

\begin{align}
\mathbfcal{M} = \left( Q, \Sigma, \Omega, \delta, \lambda, q_0 \right)
\label{def:mealy-formal}
\end{align}
\begin{align*}
	\text{mit}\\
	Q &: \text{Endliche Menge von Zuständen} \\
	\Sigma  &:\text{Endliches Eingabealphabet} \\
	\Omega  &:\text{Endliches Ausgabealphabet} \\
	\delta  &:\text{Zustandsübergangsfunktion}\ Q \times \Sigma \rightarrow Q \\
	\lambda &:\text{Ausgabefunktion}\ Q \times \Sigma \rightarrow \Omega \\
	q_0 &: \text{Startzustand}
\end{align*}

Die Definition ließe sich noch um die Menge der finalen Endzustände $F \subseteq Q$ hin zu einem 7-Tupel erweitern. In unserem Konzept verzichten wir auf definierte Endzustände, da wir prinzipiell jede Eingabe akzeptieren. Nicht akzpetierbare Eingaben stellen wir als externe Ausnahmefälle (Exceptions) dar. Ein vereinfachtes Beispiel für eine nicht akzeptierbare Eingabe ist die Eingabe $\bot$, nach der unser gesamtes System in einen undefinierten Zustand $\bot$ wechselt.

\subsubsection{Abstrakte Definition in Haskell}

Ein Mealy Automat lässt sich in Haskell abstrakt wie in \fref{lst:haskell-mealy} definieren. {\ttfamily a} beschreibt die Eingabe als Äquivalent zum Eingabealphabet $\Sigma$ der formalen Definition und analog beschreibt |b| die Ausgabe als Äquivalent zum Ausgabealphabet $\Omega$. Die Zustandsübergangsfunktion $\delta$ und die Ausgabefunktion $\lambda$ ergibt sich aus der jeweils konkreten Implementierung des Mealy. Die Menge der Zustände $Q$ wird jeweils von der konkreten Mealy Implementierung gekapselt wie in \fref{lst:state-mealy-beispiel} anhand eines Beispiels veranschaulicht. Aber es lässt sich bereits feststellen, dass die gewählte Form des Mealy Automatens weit mehr als nur ein endlicher Automat ist, da die Mächtigkeit des Ein- und Ausgabealphabets unendlich sein kann, wie dies zum Beispiel bei der Menge der natürlichen Zahlen (abzählbar unendlich) der Fall ist. Daraus folgt zusätzlich, dass auch die Menge der Zustände unendlich sein kann (Zählmaschine).

\begin{haskell}[label={lst:haskell-mealy},caption={Definition Mealy in Haskell\protect\footnotemark},float]
newtype Mealy a b = Mealy { runMealy :: a -> (b, Maely a b) }
\end{haskell}
\footnotetext{https://hackage.haskell.org/package/machines-0.4.1/docs/Data-Machine-Mealy.html}

Für diese Definition einer Meleay lassen sich einige nützlicher Klassen finden, die wir aber hier überspringen da wir in \fref{sec:konkret-rendersystem} für unsere erweiterte monadische Definition eigene Implementierungen entwickeln werden.

Allgemein lässt sich die Funktionsweise von |Mealy| wie folgt beschreiben: Zu jeder Eingabe |a| erzeugt die Ausfühung von |Mealy| durch |runMealy| eine Ausgabe |b| und einen neuen Mealy-Automaten, der die selbe Eingabesprache in die selbe Ausgabesprache übersetzt. Im einfachsten Fall ist der neu erzeugte Mealy-Automat exakt der gleiche aus dem vorherigen Schritt. Ist dies für das gesamte Eingabealphabet gegeben gilt der Automat als zustandslos.

Für die Konstruktion eines Mealy-Automatens mit lokalem Zustand folgt aus der formalen Definition \ref{def:mealy-formal} die Notwendigkeit einer Zustandsübergangsfunktion $\delta$ und einem Startzustand $q_0$. Hiefür definieren wir uns in \fref{lst:state-mealy-ctr} die Hilfsfunktion |localStateMealy|. Der erste Parameter |s -> a -> (b, s)| beschreibt die Kombination der beiden Funktionen $\delta$ und $\lambda$, der zweite Parameter den Startzustand $q_0$.

\begin{haskell}[label={lst:state-mealy-ctr},caption={[Konstruktion Mealy mit lokalem Zustand]Hilfsfunktion zur Konstruktion eines Mealy-Automatens mit lokalem Zustand}]
localStateMealy :: (s -> a -> (b, s)) -> s -> Mealy a b
localStateMealy stateTransition initState = run initState where
	run state = Mealy (\input -> 
  		let (output, state') = stateTransition state input 
		in (output, stateTransition state'))
\end{haskell}

Mit Hilfe der Funktion |localStateMealy| wird ein Mealy-Automat erzeugt, der bei jeder Ausführung die |stateTransition| Funktion auf die aktuellen Eingabe |input| und den momentanen Zustand |state| anwendet um eine Ausgabe |output| und einen neuen Zustand |state'| zu erzeugen. |output| wird in Verbindung mit dem für die nächste Ausführung neu konstruiertem Meleay-Automaten als Resultat zurück geliefert.

In \fref{lst:state-mealy-beispiel} konstruieren wir einen einfachen Mealy-Automaten der ganzzahlige Eingaben akkumuliert und ausgibt. Abschließend wird in \fref{lst:state-mealy-ausfuehrung} ein Ausführungsbeispiel für |sumMealy| demonstriert.

\begin{haskell}[label={lst:state-mealy-beispiel},caption={[Beispiel Mealy-Automat mit lokalem Zustand]Beispiel Mealy-Automat mit lokalem Zustand}]
sumMealy :: Mealy Int Int
sumMealy = localStateMealy sumInState 0 where
	sumInState state input = (state, state + input)
\end{haskell}

\begin{haskell}[label={lst:state-mealy-ausfuehrung},nolol,caption={Ausführung Mealy-Automat mit lokalem Zustand}]
> let m0 = sumMealy
> let m1 = runMealy m 5
> fst m1
0
> let m2 = runMealy m1 8
> fst m2
5
> let m3 = runMealy m2 0
> fst m3
13
\end{haskell}

\subsection{Konkrete Definition des Rendersystems}
\label{sec:konkret-rendersystem}

\subsubsection{Anforderung}
Ein konkretes Rendersystem soll sich aus mehreren \warn{isolierten} Renderschritten, den Renderpasses, zusammensetzen. Durch die rekursive Definition kann ein Renderpass wiederum ein Rendersystem darstellen, so dass zwischen Rendersystem und Renderpass nur semantisch unterschieden wird. Jeder konkrete Pass soll einen konkret definierten Eingabetypen und einen konkret definierten Ausgabetypen besitzen. Ein Renderpass übersetzt die Eingabe in eine Ausgabe und kapselt alle dafür notwendigen Zustände und Vorgänge. Zustandsveränderungen sollen nicht direkt von außen vorgenommen werden können (Kapselung). Zu dem internen Zustand eines Renderpasses können unter anderem benötigte Ressourcen wie Framebuffer oder Shader gehören. \warn{Die von einem Renderpass akquirierten Ressourcen sollen vom Renderpass gekapselt werden und nur wenn notwendig als Ausgabe exponiert werden.}

Die Definition des Mealy-Automatens aus dient als gedankliche Grundlage für die folgende Definition des Rendersystem, da wir mit \fref{lst:state-mealy-ctr} gezeigt haben, wie sich Zustände kapseln lassen. Aus den Anforderungen an das Rendersystem ergibt sich, dass wir das Konzept aus \ref{lst:haskell-mealy} noch um einen monadischen Basistypen erweitern müssen, damit wir beispielsweise Operationen in der |IO| Monade ausführen können, um beispielsweise OpenGL Aufrufe zu tätigen. Damit wir uns auf keinen konkreten monadischen Typen festlegen müssen, konstruieren wir unser Rendersystem als einen monadischen Transformator (Monad-Transformer). Die Form des monadischen Transformators erlaubt es Operationen aus einer anderen Monade, der Basismonade, in unsere Ausführung zu heben (lift). So können wir unserem Rendersystem zum Beispiel über eine |Writer|-Monade die Fähigkeit verleihen Vorgänge zu protokollieren, über deine |Reader|-Monade können sich die Renderschritte eine unveränderliche Umgebung teilen. Durch das sogenannte Stacken von Monaden ist es möglich die Eigenschaften der unterschiedlichsten Monaden mit einer Monade zusammenzufassen, es entsteht ein Monad-Stack.

\subsubsection{Definition}

Aus den oben gegebenen Anforderungen kann jetzt die Definition für |RenderSystem| in \fref{lst:definition-rendersystem} formuliert werden. |m| entspricht der Basismonade, |i| ist der Typparameter für die Eingabe in das Rendersystem und respektive |o| der Typparameter für die Ausgabe. Das Ausführen eines |RenderSystems| liefert im Gegensatz zum Mealy-Automaten eine monadische Operation mit der Ausgabe |o| und dem |RenderSystem| für die nächste Ausführung als Ergebnis zurück. In \fref{lst:rendersystem-ausfuehrung-beispiel} wird ein einfaches zustandsloses |RenderSystem| auf Basis der |Reader|-Monade definiert. Das |RenderSystem| gibt den momentanen Integerwert der Umgebung auf stdout aus und liefert den Eingabewert unverändert zurück. Der Integerwert der Reader-Monade könnte zum Beispiel einen globalen Frame-Counter repräsentieren.

\begin{haskell}[label={lst:definition-rendersystem},caption={Definition Rendersystem}]
newtype RenderSystem m i o = RenderSystem { runRenderSystem :: i -> m (o, RenderSystem m i o) }
\end{haskell}

\begin{haskell}[label={lst:rendersystem-beispiel-reader},caption={Rendersystem mit ReaderT IO als Basismonade}]
type ReaderSystem = RenderSystem (ReaderT IO Int) a a
printFrame :: ReaderSystem a a
printFrame = RenderSystem (\i -> do
	env <- ask 
	print (show ask)
	return (i,printFrame))
\end{haskell}

\begin{haskell}[label={lst:rendersystem-ausfuehrung-beispiel},caption={Ausführungsbeispiel Rendersystem}]
> let r0 = runReaderT (runRenderSystem printFrame "Hallo") 0
> fst r0
0
"Hallo"
> let r1 = runReaderT (runRenderSystem r0 "Welt!") 1
> fst r1
1
"Welt"
\end{haskell}

Das Konzept wird des Rendersystems verfo
Das Konzept verfolgt das Ziel, dass jeder Abschnitt (Pass) in der Renderpipeline ein von der Außenwelt isolierten lokalen Zustand besitzt. Der Folgezustand definiert sich über zwei Größen, entsprechend dem Mealy Konzept, aus dem momentanten Ist-Zustand und dem Input. Jeder Pass kann somit im lokalen Zustand von Zählvariablen bis hin zu Resourcen verwalten. Eingehende und ausgehende Resourcen werden klar über die Eingae und Ausgabeschnittstellen eines Passes definiert. Dies hebt sich von objektorientierten Konzepten in der Art ab, dass der Zustand des Typens nicht über diverse Methoden verändert wird (z.B. häufig über setter/getter), sondern ein Pass für eine Ausfühung alle benötigten Daten als Input erhält. Zu dieser Eingabe wird eindeutig eine Ausgabe erzeugt.

Die Mealy wurde hier um einen monadischen erweitert (Transformation). Die Notwendigkeit für eine monadischen Mealy besteht darin, dass wir in unserem Pass IO Operationen ausführen müssen, wie z.B. Ausführung von OpenGL Befehlen. Zusätzlich erhöht es die Flexibilität, so können wir auch globale Umgebungen z.B. über die Reader-Monade definieren (Anwendung DeferredSettings). Theoretisch währes es auch über monadische Komponente der Mealy möglich den lokalen Zustand, z.B. über IORef, zu exponieren. Dies liegt aber entsprechend in der Verantwortung der Implementierung.
