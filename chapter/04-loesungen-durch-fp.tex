\chapter{Lösungsansätze durch Funktionale Programmierung}\label{chap:loesungen-durch-fp}

\epigraph{"`In our profession, we desperately need all the help we can get. If a clean shop floor reduces accidents, and well-organized shop tools increase productivity, then I’m all for them."'}{James O. Coplien, \spacedlowsmallcaps{Clean Code: A Handbook of Agile Software Craftsmanship}}

Wie schon in \fref{chap:engine-ueberblick} beschrieben, sind Spiele- und Grafik-Engines äußerst komplexe Softwareprojekte. Auch wenn Haskell oft als reine akademische Sprache angesehen wird findet Haskell inzwischen praktische Anwendung in unterschiedlichen Bereichen. Haskell besitzt dabei einige Vorzüge, die viele andere Sprachen nicht bieten oder nur unter großem Aufwand bieten können. Im folgenden wird ein kleiner Einblick gegegben, wie sich die Vorzüge von Haskell, in der praktischen Entwicklung von komplexen Softwareprojekten nutzen lassen.

\section{Warum Haskell?}\label{sec:warum-haskell}
Haskell gilt als eine sehr ausdrucksstarke Programmiersprache. Viele funktionale Konzepte erlauben einen neuen und oft höhren Abstraktionsgrad als zum Beispiel in reinen Objekt orientierten Sprachen. Funktionale Programmierung erzwingt fast förmlich die Zerlegung von Problemen in kleine Teilprobleme. Die statische Typisierung elimiert eine ganze Kategorie von Fehlerquellen, die sich oft in untypisierten oder dynamisch typisierten Sprachen auftun. Die statische Typisierung und das Fehlen von implizieten Seiteneffekten sorgt für eindeutige und klare Signaturen. Auch wenn nicht jede Funktion formal auf ihre Korrektheit bewiesen werden kann, erleichtern die klaren Signaturen und die statischen Typen die Ad-hoc Beweisführung (Reasoning), die jeder Entwickler automatisch im Kopf beim Lesen von mitführt. Viele Implementierungen von Funktionen ergeben sich oft schon aus der Signatur.

Die genannten wesentlichen Eigenschaften erlauben in Kombination das Schreiben von wiederverwendbaren und komponierbaren Funktionen und führen zu verständlicheren, zugänglicheren und wartbaren Systemen \parencite[Seite 12 ff.]{Stewart2015}. Dies zeigt sich auch unter anderem dadurch, dass bereits viele kleine spezialisierte Projekte in Haskell entwickelt wurden, die sich oft leicht zu einem größeren Projekt zusammensetzen lassen. Dies wird im wesentlichen dadurch vereinfacht, dass die Verständigung über klare funktionale bzw. mathematische Konzepte und Regeln eindeutig ist. Ein |Functor| bleibt ein |Functor| und die Verwendung eines |Functor|s ist, einmal verstanden, überall anwendbar.
\cite{Sweeney2006} % Next Mainstream Programming Language

\warn{bridge}

Tim Sweeny von \textit{Epic Games} nennt das "`Shared State Concurrency"' Model aus C++/Java/C\# selber eine "`Huge productivity burden"' und weiter sagt er: "`Purely Functional is the right default"' \parencite[Vgl.][Seite 42 u. Seite 56]{Sweeney2006}. John Carmack, Gründer von \textit{id Software} und nun CTO bei \textit{Oculus VR}: "`[...] banning mutable shared state. Easier said than done, of course."' und zusätzlich "`Static analysis helps, but NULL problems remain the top fault in our codebase."'\footnote{Quelle: https://twitter.com/id\_aa\_carmack/status/325019679720615936}.

Es lässt sich durchaus schlussfolgern, dass Haskell die richtigen Lösungen (z.B.: Unveränderlichkeit von Daten, |Maybe| statt |NULL|, \textit{rein funktional} als Grundprinzip) für viele Probleme in komplexen Softwareprojekten bereits mit sich bringt. Und deswegen stellen Bindings zu komplexen externen Frameworks keine optimale Lösung dar, auch wenn dies oft aus kurz bis mittelfristigen Gründer der Produktivität immer noch erforderlich ist. Dies stellt ein gewisses Henne-Ei-Problem dar: Auf Grund der 
