\chapter{Resultat}
\label{chap:resultat}

In der vorliegenden Arbeit wurde eingangs in \fref{chap:engine-uebersicht} aus den gestiegenen Anforderungen an die Softwareprojekte in der Spielebranche die Motivation entwickelt, neue Mittel und Wege für das Beherrschen der zunehmenden Komplexität zu suchen. Die zunehmende Komplexität in Softwareprojekten erhöht die Wahrscheinlichkeit des Scheiterns von diesen Projekten. Es wurde festgestellt, dass die Programmiersprache das wichtigste Kommunikationsmittel unter den Softwareentwicklern ist. Dementsprechend spielt die Programmiersprache eine zentrale Rolle in Softwareprojekten, sie bestimmt die Kommunikation aber auch die Softwarearchitektur und die Möglichkeiten der Entwickler.

Jede Branche und jedes Projekt besitzt eigene individuelle Anforderungen und Herausforderungen. In der Grafik-Engine-Entwicklung stellen die Grafik-\ac{API}s die Kernherausforderungen. In \fref{chap:modern-opengl} wurde am Beispiel von \textit{OpenGL} die Entwicklung der Grafik-\ac{API} betrachtet und welche Herausforderungen und Möglichkeiten diese Schnittstelle mit sich bringt.

\fref{chap:loesungen-durch-fp} zitierte Entwicklergrößen aus der Spielebranche. Die getroffenen Aussagen geben die aktuellen Probleme in der Spiele- und Engine-Entwicklung wieder. Es wurde gezeigt, dass viele wesentlichen Probleme, die sich in den Industriesprachen C++ / C# oder Java auftun, in anderen Sprachen entweder konzeptionell keine Probleme darstellen oder bereits gelöst sind. Diese Diskussion wird in diesem Kapitel in \fref{xp:haskell} noch einmal abschließend aufgegriffen und um persönliche Einschätzungen des Autors erweitert.

% Aus der Motiviation heraus neue Wege und Konzepte für aktuelle Probleme in der Engine-Entwicklung zu su

\section{Diskussion der Implementierung}

\section{Erfahrungen mit Haskell}\label{sec:xp-haskell}

\subsection{Vorteile von Haskell}

{\Huge Just Notes}\\
Argument performance. auch wenn engines und echtzeit performance kritisch sind, gibt es hotspots.
Der Gründer von Epic Games (Unreal Engine) würde 10\% der Performance für 10\% mehr Produktivität opfern \parencite[Seite 20]{Sweeney2006} % Next Mainstream Programming Language

Bezüglich der Implementierung eines Renderschritts wurde auf eine Abstraktion der Grafik-API verzichtet, so dass Implementierungen direkt in OpenGL umgesetzt sind.

opt-in extensions

führt aber zu eher imperativen (opengl) implementierungen der einzelnen renderschritte. Meinung

\subsection{Probleme bei Haskell}\label{sec:probleme-haskell}

Die produktive Verwendung von Haskell bringt aber auch einige Probleme mit sich. Oft sind die Probleme aber eher organisatorischer und menschlicher Natur. Zum einen sind die funktionalen Konzepte im Vergleich zu den beispielsweise OOP Konzepten nicht auf breiter Front bekannt und erfordern auch oft neue Denkmuster. Da die bestehenden Denkmuster sich jahrelang verfestigen konnten, dürften neue Denkansätze auf einigen Widerstand stoßen. Das schrittweise Einführen von Haskell dürfte auch in Unternehmensumgebungen naturgemäß einige Widerstände und Skepsis mit sich bringen.

Generell ist das schrittweise Einführen (Drop In Replacement) von Haskell aber auch praktisch nicht immer einfach. Während in modernen Serverarchitekturen sich selektiv einige kleine isolierte Dienste mit Haskellimplementierungen ersetzen ließen, dürfte sich dies bei monolithischen Projekten als schwerer herausstellen. Auch die Verknüpfung von Haskell mit C++, in der Spieleindustrie Quasi-Standard, ist noch nicht umfassend gelöst.

Tools (voll integrierte entwicklungsumgeben - abseits von Emacs)


Es lässt sich durchaus schlussfolgern, dass Haskell die richtigen Lösungen (z.B.: Unveränderlichkeit von Daten, |Maybe| statt \texttt{NULL}, \textit{rein funktional} als Grundprinzip) für viele Probleme in komplexen Softwareprojekten bereits mit sich bringt. Und deswegen stellen Bindings zu komplexen externen Frameworks keine optimale Lösung dar, auch wenn dies oft aus kurz bis mittelfristigen Gründer der Produktivität immer noch erforderlich ist. Dies stellt ein gewisses Henne-Ei-Problem dar: Auf Grund der 

Abstraktion ermöglicht optimierungen des Compilers:
Mehr anwendung von haskell, mehr workforce für den compiler, bessere optimierungen
low hangig fruits in c vermutlich schon abgefisch, in ghc noch viele bereiche offen
