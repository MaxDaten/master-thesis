\chapter{Funktionale Programmierung \& Modern OpenGL}
\label{chap:haskell-modern-gl}

Wie schon in \fref{chap:engine-ueberblick} beschrieben, sind Spiele- und Grafik-Engines äußerst komplexe Softwareprojekte. Auch wenn Haskell oft als reine akademische Sprache angesehen wird findet Haskell inzwischen praktische Anwendung in unterschiedlichen Bereichen. Haskell besitzt dabei einige Vorzüge, die viele andere Sprachen nicht bieten oder nur unter großem Aufwand bieten können. Im folgenden wird ein kleiner Einblick gegegben, wie sich die Vorzüge von Haskell, in der praktischen Entwicklung von komplexen Softwareprojekten nutzen lassen.

\section{Warum Haskell?}\label{sec:warum-haskell}
Haskell gilt als eine sehr ausdrucksstarke Programmiersprache. Viele funktionale Konzepte erlauben einen neuen und oft höhren Abstraktionsgrad als zum Beispiel in reinen Objekt orientierten Sprachen. Funktionale Programmierung erzwingt fast förmlich die Zerlegung von Problemen in kleine Teilprobleme. Die statische Typisierung elimiert eine ganze Kategorie von Fehlerquellen, die sich oft in untypisierten oder dynamisch typisierten Sprachen auftun. Die statische Typisierung und das Fehlen von implizieten Seiteneffekten sorgt für eindeutige und klare Signaturen. Auch wenn nicht jede Funktion formal auf ihre Korrektheit bewiesen werden kann, erleichtern die klaren Signaturen und die statischen Typen die Ad-hoc Beweisführung (Reasoning), die jeder Entwickler automatisch im Kopf beim Lesen von mitführt. Viele Implementierungen von Funktionen ergeben sich oft schon aus der Signatur.

Die genannten wesentlichen Eigenschaften erlauben in Kombination das Schreiben von wiederverwendbaren und komponierbaren Funktionen und führen zu verständlicheren, zugänglicheren und wartbaren Systemen \parencite[Seite 12 ff.]{Stewart2015}. Dies zeigt sich auch unter anderem dadurch, dass bereits viele kleine spezialisierte Projekte in Haskell entwickelt wurden, die sich oft leicht zu einem größeren Projekt zusammensetzen lassen. Dies wird im wesentlichen dadurch vereinfacht, dass die Verständigung über klare funktionale bzw. mathematische Konzepte und Regeln eindeutig ist. Ein |Functor| bleibt ein |Functor| und die Verwendung eines |Functor|s ist, einmal verstanden, überall anwendbar.
\cite{Sweeney2006} % Next Mainstream Programming Language

\warn{bridge}

Tim Sweeny von \textit{Epic Games} nennt das "`Shared State Concurrency"' Model aus C++/Java/C\# selber eine "`Huge productivity burden"' und weiter sagt er: "`Purely Functional is the right default"' \parencite[Vgl.][Seite 42 u. Seite 56]{Sweeney2006}. John Carmack, Gründer von \textit{id Software} und nun CTO bei \textit{Oculus VR}: "`[...] banning mutable shared state. Easier said than done, of course."' und zusätzlich "`Static analysis helps, but NULL problems remain the top fault in our codebase."'\footnote{Quelle: https://twitter.com/id\_aa\_carmack/status/325019679720615936}.

Es lässt sich durchaus schlussfolgern, dass Haskell die richtigen Lösungen (z.B.: Unveränderlichkeit von Daten, |Maybe| statt |NULL|, \textit{rein funktional} als Grundprinzip) für viele Probleme in komplexen Softwareprojekten bereits mit sich bringt. Und deswegen stellen Bindings zu komplexen externen Frameworks keine optimale Lösung dar, auch wenn dies oft aus kurz bis mittelfristigen Gründer der Produktivität immer noch erforderlich ist. Dies stellt ein gewisses Henne-Ei-Problem dar: Auf Grund der 

\section{Probleme bei Haskell}\label{sec:probleme-haskell}

Die produktive Verwendung von Haskell bringt aber auch einige Probleme mit sich. Oft sind die Probleme aber eher organisatorischer und menschlicher Natur. Zum einen sind die funktionalen Konzepte im Vergleich zu den beispielsweise OOP Konzepten nicht auf breiter Front bekannt und erfordern auch oft neue Denkmuster. Da die bestehenden Denkmuster sich jahrelang verfestigen konnten, dürften neue Denkansätze auf einigen Widerstand stoßen. Das schrittweise Einführen von Haskell dürfte auch in Unternehmensumgebungen naturgemäß einige Widerstände und Skepsis mit sich bringen.

Generell ist das schrittweise Einführen (Drop In Replacement) von Haskell aber auch praktisch nicht immer einfach. Während in modernen Serverarchitekturen sich selektiv einige kleine isolierte Dienste mit Haskellimplementierungen ersetzen ließen, dürfte sich dies bei monolithischen Projekten als schwerer herausstellen. Auch die Verknüpfung von Haskell mit C++, in der Spieleindustrie Quasi-Standard, ist noch nicht umfassend gelöst.


\begingroup
\setlength\intextsep{0pt}
\section{Anwendung von Haskell mit Modern OpenGL Konzepten}

Viele der in \fref{sec:overhead-und-flexibilitaet} genannten Erweiterungen wurden mit dem Ziel entwickelt die OpenGL API zu vereinfachen. Die neuen Konzepte harmonieren dabei sehr gut mit OpenGL.

\paragraph{\acl{DSA} \& Separate Program Objects} und die verstärkte Verwendung von Buffern für Daten und Kommandos (\ac{MDI}) und der dadurch reduzierte API Overhead soll neue Spielräume eröffnen. Während dies oft damit beworben wird, dass die CPU wieder interessantere Dinge tun kann, lässt sich auch argumentieren, dass sich die neuen Spielräume für gänzlich neue Ansätze in der Projektstruktur und Wahl der Mittel nutzen lassen. Die generelle Reduzierung des Overheads kommt dabei auch Haskell zugute. Zusätzlich lässt sich aber auch Haskell dazu als Hebel nutzen, um die bessere Modularität von \ac{DSA} voll auszuschöpfen.

\begin{wrapfigure}{r}{0.5\linewidth}
\centering
\fbox{
\begin{minipage}[t]{0.9\linewidth}
\begin{smaller}
\paragraph{Quine}
Quine\footnote{https://github.com/ekmett/quine/} ist ein kleines Hobby Projekt von Edward Kmett. Aktuell basiert das Projekt auf den neuen OpenGL Haskell-Bindings der \texttt{gl} Bibliothek. Die Demo Szenen sind aktuell nur Fragment-Shader Demos von Shadertoy\footnote{https://www.shadertoy.com/}. Langfristiges Ziel von Quine ist laut Edward Kmett eine Bibliothek in Haskell zu erschaffen die eine Sammlung der Best-Practices von Modern OpenGL zugänglich macht. Der Autor dieser Arbeit beteiligt sich an dem Projekt und hat schon kleinere allgemeine Teile aus der hier beschriebenen Engine nach Quine portiert.
\end{smaller}
\end{minipage}
}
\end{wrapfigure}

Die \textit{Separate Program Objects} lassen sich dabei schon in OpenGL 4.1 als Vorboten von \ac{DSA} betrachten. Wie bereits beschrieben lassen sich über diese OpenGL Erweiterung die Uniform Variablen der einzelnen Shader-Stufen direkt über das Program-Objekt setzen. In Verbindung mit einer |StateVar| (siehe Beispielimplementierung \fref{sec:src-statevar}) und wenigen zusätzlichen Definitionen, lassen sich in Haskell elegante Schnittstellendatentypen für Shader definieren, die sich in Zukunft automatisch generieren ließen. \ref{lst:uniform-beispiel} gibt ein Beispiel wie sich eine Shader-Schnittstelle über funktionale Konzepte zusammensetzen lässt.

\endgroup
% Viele Portierungen von Konsole zu PC erwiesen sich oft als zusätzlich aufwändig, da spezielle Optimierungen auf einzelne Anwendungen die Wartung entsprechender Abschnitte deutlich erschwerten (\warn{BELEG}).
